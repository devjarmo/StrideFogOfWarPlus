0) What is triangle count with various layers of fog?
	- (3) Layers is ~1,201,200
	- (1) Layers is ~761,334.
	- Could the the Sphere Models.
0) Lighting could be adjusted.
	- Convert the enemies to Cubes? Maybe later.
=============================================
=============================================
=============================================

Next Steps:
===========

0) Implement a two layer fog system for saving triangles.
	- Decrease the darkness of shadows, perhaps by modifying the light source.
0) Design the new Dynamic Line Of Sight Detector prefab.
	- This can use the same texture as the detector.
0) Write a method for raycasting LEFT to RIGHT, dump to an array of float2(angle, distance).
0) Material will need to be in the render group 


=============================================
Line Of Sight Pseudo Code:
==========================

1) Input should be radius and angle step.
	- 360 is divisible by?
	- Should be an enum?
		-1, 2, 5, 10
2) Raycast every angle step and record the distance.
	- Raycast until <= 360.
	- Use the formula from the next steps document to determine the destination point.
	- Use real world position information for source and destination (will need to add back in the offset).
	- Will need to penetrating raycast and check for any static colliders.
	- If there are multiple, grab the closest one.
3) Create a "slice" object and record Dictionary (clampedAngle, angleDistance, raycastDistance).
4) Link the first and last "slices" in the "next slice"




Shading calculations:
=====================

angle = position clamp to an angle.

shaderDistance = distance from center

raycastDistance = dictionary[angle] lookup

if shaderDistance < raycastDistance return 1.

else if left of step/2 "<", check left, if shaderDistance < LEFT raycast Distance
	return distance abs(angle - ClampAngle)/(step/2).

else if right of step/2 ">", check right, if shader shaderDistance < RIGHT raycast Distance
	return distance abs(angle - ClampAngle)/(step/2)

=============================================

Any point (x,y) on the path of the circle is x = r * sin(θ), y = r * cos(θ).

thus: (x,y) = (12*sin(115), 12*cos(115))

So your point will roughly be (10.876, -5.071) (assuming the top right quadrant is x+, y+)


[IF THERE IS AN OFFSET (WORLD SPACE)]

x = cx + r * cos(a)
y = cy + r * sin(a)

Where r is the radius, cx,cy the origin, and a the angle.

That's pretty easy to adapt into any language with basic trig functions. Note that most languages will use radians for the angle in trig functions, so rather than cycling through 0..360 degrees, you're cycling through 0..2PI radians.
